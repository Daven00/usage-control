package it.cnr.iit.ucs.requestmanager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;

import it.cnr.iit.utility.JAXBUtility;
import it.cnr.iit.xacml.Attribute;
import it.cnr.iit.xacml.Category;
import it.cnr.iit.xacml.DataType;
import oasis.names.tc.xacml.core.schema.wd_17.ApplyType;
import oasis.names.tc.xacml.core.schema.wd_17.AttributeDesignatorType;
import oasis.names.tc.xacml.core.schema.wd_17.AttributeValueType;
import oasis.names.tc.xacml.core.schema.wd_17.ConditionType;
import oasis.names.tc.xacml.core.schema.wd_17.ObligationExpressionType;
import oasis.names.tc.xacml.core.schema.wd_17.ObligationExpressionsType;
import oasis.names.tc.xacml.core.schema.wd_17.PolicyType;
import oasis.names.tc.xacml.core.schema.wd_17.RuleType;

/**
 * This is a wrapper for the policy class.
 * 
 * <p>
 * Using JAXB we do not need to manually parse the XML file anymore. However we
 * still need to access in a smart and fast ways the various parts of the XML
 * file. That is why we will use this class of helper functions to perform this
 * task. <br>
 * The Classes generated by xjc provide all the methods to perform get and set,
 * we will exploit those methods providing higher level classes.
 * 
 * <br>
 * The methods we will need to extract the informations from the xml are:
 * <ol>
 * <li>retrieve attributes needed to evaluate a policy</li>
 * <li>retrieve on going attributes</li>
 * <li>retrieve obligations</li>
 * </ol>
 * 
 * This class needs to be employed because in this way we can abstract the
 * underlying implementation, this means that if, in the future, we do not want
 * to use JAXB anymore but other methods we will have just to change the
 * implementation of those methods.
 * </p>
 * <p>
 * This PolicyHelper implements the PolicyHelperInterface, since, for the moment
 * we will use only the Policy tag (hence no policy set is used for now) and
 * since we want to use the JAXB to parse the xml, this class will extend the
 * PolicyType class provided by the JAXB.
 *
 * </p>
 * <p>
 * This class will use only factory methods and not constructor. This because it
 * is possible that the policy used does not contain some informations and we do
 * not want to allow the UCS to deal with damaged files.
 * </p>
 * 
 * @author antonio
 *
 */
public class PolicyHelper implements PolicyHelperInterface {

	// the policy type object
	private PolicyType policyType;

	private final static Logger LOGGER = Logger.getLogger(PolicyHelper.class.getName());

	/**
	 * private constructor to avoid possible instantiation of this class
	 */
	private PolicyHelper() {

	}

	/**
	 * Builds a PolicyHelper object starting from the xml description provided in
	 * the string
	 * 
	 * @param string the xml that describes the policy
	 * @return a PolicyHelper object if everything goes ok, null otherwise
	 */
	public static PolicyHelper buildPolicyHelper(String string) {
		// BEGIN PARAMETER CHECKING
		if (string == null || string.isEmpty()) {
			throw new NullPointerException("PolicyHelper.buildPolicyHelper string parameter is null or empty");
		}
		// END PARAMETER CHECKING

		PolicyHelper policyHelper = new PolicyHelper();
		try {
			policyHelper.policyType = JAXBUtility.unmarshalToObject(PolicyType.class, string);
			return policyHelper;
		} catch (Exception exception) {
			exception.printStackTrace();
			return null;
		}
	}

	@Override
	public List<Attribute> getAttributesForCondition(String conditionName) {
		// BEGIN PARAMETER CHECKING
		if (conditionName == null || conditionName.isEmpty()) {
			throw new NullPointerException("PolicyHelper.buildPolicyHelper string parameter is null or empty");
		}
		// END PARAMETER CHECKING
		HashMap<String, Attribute> attributes = new HashMap<>();
		List<Object> list = policyType.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition();
		for (Object obj : list) {
			if (obj.getClass().toString().contains("RuleType")) {
				RuleType ruleType = (RuleType) obj;
				// if (ruleType.getRuleId().equals("rule-permit")) {
				List<ConditionType> conditions = ruleType.getCondition();
				if (conditions != null) {
					for (ConditionType conditionType : conditions) {
						if (conditionType.getDecisionTime() == null) {
							if (conditionName.equals("pre")) {
								List<Attribute> tmp = extractAttributes(conditionType);
								for (Attribute attribute : tmp) {
									attributes.put(attribute.getAttributeId(), attribute);
								}
							} else {
								// return new ArrayList<Attribute>();
							}
						}
						if (conditionType.getDecisionTime().equals(conditionName)) {
							List<Attribute> tmp = extractAttributes(conditionType);
							for (Attribute attribute : tmp) {
								attributes.put(attribute.getAttributeId(), attribute);
							}
						}
					}
				}
			}
		}

		LOGGER.log(Level.WARNING, "Condition not found " + conditionName);
		List<Attribute> returnedList = new ArrayList<Attribute>();
		returnedList.addAll(attributes.values());
		return returnedList;
	}

	/**
	 * Function that effectively extracts the attributes from the condition.
	 * <p>
	 * The attribute object we have built up, embeds two different complex types in
	 * the xsd: one is the AttributeDesignator, the other is the attribute value.
	 * </p>
	 * 
	 * @param conditionType the condition we are analyzing
	 * @return the list of attributes types interested by this condition.
	 */
	private List<Attribute> extractAttributes(ConditionType conditionType) {
		ArrayList<JAXBElement<?>> listE = new ArrayList<JAXBElement<?>>();
		ArrayList<Attribute> attributes = new ArrayList<>();
		listE.add(conditionType.getExpression());
		Attribute attribute = new Attribute();
		int j = 0;
		for (int i = 0; i < listE.size(); i++) {

			JAXBElement<?> element = listE.get(i);
			if (element.getValue().getClass().toString().contains("ApplyType")) {
				listE.addAll(((ApplyType) element.getValue()).getExpression());
			} else if (element.getValue().getClass().toString().contains("AttributeDesignator")) {
				AttributeDesignatorType attributeDesignatorType = (AttributeDesignatorType) element.getValue();

				attributes.get(j).setCategory(Category.toCATEGORY(attributeDesignatorType.getCategory()));
				attributes.get(j).setAttributeId(attributeDesignatorType.getAttributeId());
				attributes.get(j).setDataType(DataType.toDATATYPE(attributeDesignatorType.getDataType()));
				j += 1;
			} else if (element.getValue().getClass().toString().contains("AttributeValue")) {
				AttributeValueType ad = (AttributeValueType) element.getValue();
				/*
				 * System.out.println( "1AV: " + ad.getDataType() + "\t" +
				 * ad.getContent().toString());
				 */
				for (Object obj : ad.getContent()) {
					attribute.setAttributeValues(ad.getDataType(), obj.toString());
				}
				attributes.add(attribute);
				attribute = new Attribute();
			}
		}
		return attributes;
	}

	@Override
	public String retrieveObligations() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getRuleCombiningAlgorithmId() {
		return policyType.getRuleCombiningAlgId();
	}

	/**
	 * Retrieves the particular condition for the evaluation.
	 * <p>
	 * Basically in a UXACML policy we may have more than one condition for a rule,
	 * in general we have 3 conditions: one for pre, one for ongoing and the other
	 * for post. With this function we basically want to extract the only condition
	 * in which we're interested in. However we also want the new policy to resemble
	 * the old one as much as possible.
	 * 
	 * <br>
	 * 
	 * Conditions are held in the RuleType inside the
	 * combinerParametersOrRuleCombinerParametersOrVariableDefinition of the
	 * PolicyType.
	 * 
	 * Once a RuleType object inside that list has been identified, we look for the
	 * condition in which we are interested in if the ruletype contiains conditions,
	 * otherwise we simply put the rule inside the new policy. In general ruletypes
	 * that do not contain any Condition are the default ones.
	 * </p>
	 * 
	 * @param conditionName the name of the condition in which we're interested into
	 * @return a copy of the actual policy containing only the conditions in which
	 *         we're interested into in the String format
	 */
	@Override
	public String getConditionForEvaluation(String conditionName) {
		PolicyType tmp = copyPolicy();

		/**
		 * This is the most delicate part of this function.
		 * <p>
		 * Basically if in the list of
		 * combinerParametersOrRuleCombinerParametersOrVariableDefinition there is a
		 * ruleType then it must be analyzed in order to retrieve only the part of the
		 * condition in which we're interested into. Otherwise the object will be copied
		 * inside the copy policy type.
		 * </p>
		 */
		List<Object> list = policyType.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition();
		for (Object obj : list) {
			if (obj.getClass().toString().contains("RuleType")) {
				RuleType ruleType = (RuleType) obj;
				ruleType = addObligationToRule(ruleType);
				// check if the ruletype contians any conditions
				if (ruleType.getCondition() != null && ruleType.getCondition().size() != 0) {
					List<ConditionType> conditions = ruleType.getCondition();
					for (ConditionType conditionType : conditions) {

						if (conditionType.getDecisionTime() == null) {
							if (conditionName.equals("pre")) {
								RuleType tmpRuleType = copyRuleType(ruleType, conditionType);
								tmp.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition()
										.add(tmpRuleType);
							} else {
								RuleType tmpRuleType = DefaultPermitRule.getInstance();
								tmpRuleType.setObligationExpressions(ruleType.getObligationExpressions());
								tmp.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition()
										.add(tmpRuleType);
							}
						} else if (conditionType.getDecisionTime().equals(conditionName)) {
							RuleType tmpRuleType = copyRuleType(ruleType, conditionType);
							tmp.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(tmpRuleType);
							break;
						}
					}
				} else {
					tmp.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(ruleType);
				}
			} else {
				tmp.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(obj);
			}
		}
		try {
			return JAXBUtility.marshalToString(PolicyType.class, tmp, "Policy", JAXBUtility.SCHEMA);
		} catch (JAXBException exception) {
			exception.printStackTrace();
			return null;
		}
	}

	private RuleType addObligationToRule(RuleType ruleType) {
		ObligationExpressionType obligationExpression = new ObligationExpressionType();
		obligationExpression.setFulfillOn(ruleType.getEffect());
		obligationExpression.setObligationId(ruleType.getRuleId());
		ObligationExpressionsType obligationExpressionsType = new ObligationExpressionsType();
		obligationExpressionsType.getObligationExpression().add(obligationExpression);
		ruleType.setObligationExpressions(obligationExpressionsType);
		return ruleType;
	}

	/**
	 * Copies the ruletype passed as parameter building a new ruletype object.
	 * Instead of copying all the conditions, however, it simply copies the one that
	 * we pass as parameter.
	 * 
	 * @param ruleType      the ruletype object we want to copy
	 * @param conditionType the condition to be put inside the new ruletype object
	 * @return the ruletype object built in this way
	 */
	private RuleType copyRuleType(RuleType ruleType, ConditionType conditionType) {
		RuleType tmpRuleType = new RuleType();
		tmpRuleType.getCondition().add(conditionType);
		tmpRuleType.setAdviceExpressions(ruleType.getAdviceExpressions());
		tmpRuleType.setDescription(ruleType.getDescription());
		tmpRuleType.setObligationExpressions(ruleType.getObligationExpressions());
		tmpRuleType.setEffect(ruleType.getEffect());
		tmpRuleType.setRuleId(ruleType.getRuleId());
		tmpRuleType.setTarget(ruleType.getTarget());

		return tmpRuleType;
	}

	/**
	 * Performs a copy of the policy object stored in this object.
	 * <p>
	 * The only part that will be left outside is the part is the list
	 * combinerParametersOrRuleCombinerParametersOrVariableDefinition which will be
	 * analyzed later. This because we may require in the new policy to have only a
	 * part of that list
	 * </p>
	 * 
	 * @return the PolicyType object that is the copy of the one stored in this
	 *         object
	 */
	private PolicyType copyPolicy() {
		PolicyType tmp = new PolicyType();
		tmp.setDescription(policyType.getDescription());
		tmp.setPolicyId(policyType.getPolicyId());
		tmp.setPolicyIssuer(policyType.getPolicyIssuer());
		tmp.setAdviceExpressions(policyType.getAdviceExpressions());
		tmp.setMaxDelegationDepth(policyType.getMaxDelegationDepth());
		tmp.setPolicyDefaults(policyType.getPolicyDefaults());
		tmp.setRuleCombiningAlgId(policyType.getRuleCombiningAlgId());
		tmp.setTarget(policyType.getTarget());
		tmp.setVersion(policyType.getVersion());
		tmp.setObligationExpressions(policyType.getObligationExpressions());
		return tmp;
	}

}
